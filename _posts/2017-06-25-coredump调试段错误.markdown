---
layout: post
title:  "Core dump调试段错误"
date:   2017-06-25 16:15:00 +0800
---
**一、前言**
----

在做项目的时候，遇到了段错误的问题，由于文件比较多，代码量较大，使用GDB的单步跟踪很难找到问题所在，查阅资料得知可以使用coredump进行段错误排查，所以今天总结一下解决问题的方法。有时编写的程序可以通过编译, 但在运行时会出现Segment fault(段错误)。这通常都是指针错误引起的。但这不像编译错误一样会提示到文件某一行, 而是没有任何信息, 使得我们的调试变得困难起来。

**二、什么是core**
---------

由于在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料，线圈就叫作 core，用线圈做的内存就叫作core memory。如今，半导体工业澎勃发展，已经没有人用 core memory了，不过，在许多情况下，人们还是把记忆体叫作core。

**三、什么是coredump**
-------------

当程序运行过程中发生异常，程序异常退出时，操作系统就会把程序当掉时的内存内容dump 出来（现在通常是写在一个叫 core 的 file 里面），让程序员做为参考。这个动作就叫作core dump。

**四、core文件的生成**
-----------

有时候程序异常终止了, 但是core文件却没有生成，主要是当前系统的环境设置问题, 可以用下面的指令设置一下, 然后再运行程序便成生成core文件：ulimit -c unlimited。core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号。以上设置仅对当前shell窗口有效，可以通过修改/etc/profile，添加ulimit -S -c unlimited > /dev/null 2>&1，这样设置后系统允许所有用户生成没有大小限制的core dump文件。注：使用sudo  source /etc/profile，使修改生效。

**五、如何使用core文件**
------------

在Linux下，使用：
```
#gdb -c core.pid program_name 
```
就可以进入gdb模式。 
输入where，就可以指出是在哪一行被Down掉，哪个function内，由谁调用等等。

(gdb) where 

或者输入 bt

(gdb) bt

**六、造成程序core dump的原因**
------------------

1.内存访问越界

 （1）数组访问越界

 （2）搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符
  
 （3）使用strcpy, strcat, sprintf,strcmp,strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat,snprintf, strncmp, strncasecmp等函数防止读写越界。
  
 （4）栈溢出
 
2.多线程程序使用了线程不安全的函数。

 对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump

3.多线程读写的数据未加锁保护。

4.非法指针

（1）使用空指针

（2）随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump。
>参考文献
- http://blog.csdn.net/love_gaohz/article/details/7497557
- http://www.embeddedlinux.org.cn/html/jishuzixun/201307/08-2594.html

